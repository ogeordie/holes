# Holes

# Holes is a program for simulations of archaeological excavations.

# Copyright 2024-2025 Geordie Oakes

# This program is free software: you can redistribute it and/or modify it under the terms of 
# the GNU General Public License v3 as published by the Free Software Foundation.

# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
# See the GNU General Public License v3 for more details.

# You should have received a copy of the GNU General Public License along with this program. 
# If not, see https://www.gnu.org/licenses/gpl-3.0.html.


# See the "README.md" file for information, and installation and usage instructions.


# This file contains code to plot graphs and tables using the matplotlib library.
# It expects csv data files as generated by Holes.py.

import numpy as np
import matplotlib.pyplot as plt
import csv
from pathlib import Path

# Plots experiments with small holes and with big holes. Also optionally plots the small
# strategy at different ratios (if "ratios" is True). The filenames supplied should
# not include a path, and will be looked for in the "data" directory.
# "title" is the title of the graph, "endx" is the maximum value on the x axis,
# and "intervalx" is the interval between ticks on the x axis. Note that
# endx must divide by intervalx.
def plotExperiment(smallHolesFileName:str, bigHolesFileName:str, outputFileName:str, title:str, endx:int, intervalx, ratios:bool=False):

    if (endx % intervalx != 0):
        print("plotExperiment requires that endx divides by intervalx");
        return;

    xsmall = [];
    ysmall = [];

    xbig = [];
    ybig = [];

    if (ratios):
        x2ratio = []
        x3ratio = [];
        x4ratio = []

    # read the data from csv files into the arrays
    smallCsvFile = open("data/"+smallHolesFileName, 'r');
    bigCsvFile = open("data/"+bigHolesFileName, 'r');
    smallLines = csv.DictReader(smallCsvFile, delimiter=',', skipinitialspace=True);
    bigLines = csv.DictReader(bigCsvFile, delimiter=',', skipinitialspace=True);
    maxHole1x1 = 0;
    for row in smallLines:
        if row['successrate'] != '':
            xsmall.append(int(row['actualholes']));
            ysmall.append(float(row['successrate']));
            smallMaxHole = int(row['actualholes']);
    smallCsvFile.close();

    for row in bigLines:
        if (row['successrate']) != '':
            xbig.append(int(row['actualholes']))
            ybig.append(float(row['successrate']))
            bigMaxHole = int(row['actualholes'])
    bigCsvFile.close();

    # create the x axis values for the ratios
    if (ratios):
        x2ratio = [z/2 for z in xsmall];
        x3ratio = [z/3 for z in xsmall];
        x4ratio = [z/4 for z in xsmall];

    fig = plt.figure()
    ax1 = fig.add_subplot(111)

    # set up the x axis ticks for ax1
    ax1.set_xlim(0, endx);
    ax1.set_ylim(0, 100);
    ax1.set_xticks(np.arange(0, endx + intervalx, intervalx));
    ax1.set_yticks(np.arange(0, 110, 10));
    ax1.set_xlabel('number of test pits')
    ax1.set_ylabel('success rate')

    # set up and plot the ratio lines and axes
    if (ratios):
        fig.subplots_adjust(bottom=0.35)

        ax2 = ax1.twiny()
        ax3 = ax1.twiny();
        ax4 = ax1.twiny();
        x1ticks = ax1.get_xticks();
#        ax1.set_xlim(0, x1ticks[x1ticks.size - 1]);
        ax4.set_xlim(0, endx);
    
        # plot the data on ax4 so that the grid sits behind the lines rather than on top of it
        ax4.plot(xsmall, ysmall, color = 'black', linestyle="dotted", label = "{}m\u00b2 pits (1:1 ratio)".format(0.25));
        ax4.plot(xbig, ybig, color = 'black', linestyle="dashed", label = "{}m\u00b2 pits (1:1 ratio)".format(1));
        ax4.plot(x2ratio, ysmall, color="red", label="2:1 ratio ({}m\u00b2)".format(0.25))
        ax4.plot(x3ratio, ysmall, color="blue", label="3:1 ratio ({}m\u00b2)".format(0.25))
        ax4.plot(x4ratio, ysmall, color="green", label="4:1 ratio ({}m\u00b2)".format(0.25))

        ax2.xaxis.set_ticks_position("bottom")
        ax2.xaxis.set_label_position("bottom")
        ax3.xaxis.set_ticks_position("bottom")
        ax3.xaxis.set_label_position("bottom")
        ax4.xaxis.set_ticks_position("bottom")
        ax4.xaxis.set_label_position("bottom")

        ax2.spines["bottom"].set_position(("axes", -0.18))
        ax3.spines["bottom"].set_position(("axes", -0.32))
        ax4.spines["bottom"].set_position(("axes", -0.45))

        ax2.set_frame_on(True)
        ax2.patch.set_visible(False)
        ax3.set_frame_on(True)
        ax3.patch.set_visible(False);
        ax4.set_frame_on(True)
        ax4.patch.set_visible(False);
    
        for sp in ax2.spines.values():
            sp.set_visible(False)
        for sp in ax3.spines.values():
            sp.set_visible(False)
        for sp in ax4.spines.values():
            sp.set_visible(False)
        ax2.spines["bottom"].set_visible(True)
        ax3.spines["bottom"].set_visible(True)
        ax4.spines["bottom"].set_visible(True)

        ax2.spines["bottom"].set_color("red");
        ax3.spines["bottom"].set_color("blue");
        ax4.spines["bottom"].set_color("green");

        ax2.tick_params(colors='red');
        ax3.tick_params(colors='blue');
        ax4.tick_params(colors='green');

        ax2.xaxis.label.set_color('red');
        ax3.xaxis.label.set_color('blue');
        ax4.xaxis.label.set_color('green');

        ax2.set_xticks(x1ticks);
        ax2.set_xticklabels([z * 2 for z in x1ticks]);
        ax3.set_xticks(x1ticks);
        ax3.set_xticklabels([z * 3 for z in x1ticks]);
        ax4.set_xticks(x1ticks);
        ax4.set_xticklabels([z * 4 for z in x1ticks]);

    else:
        # ratios is False, plot the lines on ax1
        ax1.plot(xsmall, ysmall, color = 'black', linestyle="dotted", label = "{}m\u00b2 pits".format(0.25));
        ax1.plot(xbig, ybig, color = 'black', linestyle="dashed", label = "{}m\u00b2 pits".format(1));


    ax1.grid(visible=True, axis="both");
    if (ratios):
        ax2.grid(visible=True, axis="both");
        ax3.grid(visible=True, axis="both");
        ax4.grid(visible=True, axis="both");
        
    plt.title(title + "\n", fontsize = 12)
    
    if ratios:
        ax4.legend(loc="lower right");
    else:
        ax1.legend(loc="lower right");
    
    fig.tight_layout()
    plt.draw()

    # save the graph, creating the graphs directory if necessary
    outputFile = Path("graphs/" + outputFileName);
    outputFile.parent.mkdir(exist_ok=True, parents=True)
    plt.savefig("graphs/" + outputFileName);

# plot a table with the data. Data is a 2-D array, with an inner array for each
# row in the table. The first row is assumed to have column titles.
# figwidth and figheight are the dimensions of the graph. 
# scalex and scaley are the amount to scale the graph in each direction (e.g. 2, 2).
# outputFileName is where the table is stored. This should not contain a path,
# and will be placed in the "graphs" directory.
# cellHeight defines the height of the non-title rows.
def plotTable(data:list, figwidth:float, figheight:float, scalex:float, scaley:float, outputFileName:str, cellHeight:float = -1):
    fig, ax = plt.subplots(figsize=(figwidth, figheight));
    ax.axis('off')  # Hide axes for cleaner table display

    # make the title background grey
    ccolors = np.full(len(data[0]), 'lightgrey')

    # create the table
    table = ax.table(cellText=data[1:], colLabels=data[0], loc='center', cellLoc='left', colColours=ccolors);
    table.auto_set_font_size(False);
    table.auto_set_column_width(col=list(range(len(data))))

    if (cellHeight != -1):
        for (row, col), cell in table.get_celld().items():
            if (row > 0):
                cell.set_height(cellHeight);
    table.scale(scalex, scaley)  # Adjust table size

    # draw the table and save it in the graphs directory (creating it if needed)
    plt.draw();
    outputFile = Path("graphs/" + outputFileName);
    outputFile.parent.mkdir(exist_ok=True, parents=True)
    plt.savefig("graphs/" + outputFileName);
    
